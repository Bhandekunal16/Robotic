const readline = require("readline");
const fs = require("fs");

class Core {
  async readLines(path) {
    const readStream = fs.createReadStream(path, { encoding: "utf8" });
    let array = [];

    const rl = readline.createInterface({
      input: readStream,
      crlfDelay: Infinity,
    });

    rl.on("line", (line) => {
      // line = line.replace(/\s+/g, "");

      if (line.includes("function") && !line.includes("async")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(function)\b/, "\nfunction ");
        }
      } else if (
        line.includes("class") &&
        !line.includes("/") &&
        !line.includes("export")
      ) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(class)\b/, "\nclass ");
        }
      } else if (line.includes("module") && !line.includes("/")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(module)\b/, "\nmodule ");
        }
      } else if (line.includes("import") && !line.includes(";")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(import)\b/, "\nimport ");
        }
      } else if (line.includes("export")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(export)\b/, "\nexport ");
        }
      } else if (line.includes("try")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(try)\b/, "\n    try ");
        }
      } else if (
        /@(Post\([^)]*\)|Get\([^)]*\)|Patch\([^)]*\)|Delete\([^)]*\))/.test(
          line
        )
      ) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(
            /@(Post\([^)]*\)|Get\([^)]*\)|Patch\([^)]*\)|Delete\([^)]*\))/g,
            "\n@$1\n"
          );
        }
      } else if (line.includes("constructor")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(constructor)\b/, "\n    constructor ");
        }
      } else if (line.includes("catch")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(catch)\b/, "\n    catch ");
        }
      } else if (line.includes("if")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(if)\b/, "\n        if ");
        }
      } else if (/\brequire\b/.test(line)) {
        if (!/\n\s*\n/.test(line)) {
          let parts = line.split(/\b(require)\b/);
          line =
            parts[0] +
            parts
              .slice(1)
              .map((part) => {
                if (part === "require") {
                  return "\n    require";
                } else {
                  return part;
                }
              })
              .join("");
        }
      } else if (/^\s*const\b/.test(line) && line.includes("{")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/^\s*const\b/, "\n        const ");
        }
      } else if (/^\s*let\s+/.test(line) && !/for\s*\(.*\s+let\s/.test(line)) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/^\s*let\s+/, "\n        let ");
        } else {
          line = line.replace(/^\s*let\s+/, "\nlet ");
        }
      } else if (/\breturn\b/.test(line)) {
        line = line.replace(/\breturn\b/, " return  ");
      } else if (line.includes("else")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\b(else)\b/, "\n        else ");
        }
      } else if (line.includes(";") && !line.includes("for")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(";", ";\n");
        }
      } else if (line.includes("}")) {
        if (!/\n\s*\n/.test(line)) {
          line = line.replace(/\s*}/g, "}");
        }
      }

      array.push(line);
    });

    rl.on("close", () => {
      const content = array.join("");
      this.writeLines(path, content);
    });
  }

  writeLines(path, content) {
    fs.writeFile(path, content, (error) => {
      return new Error(error);
    });
  }
}

module.exports = Core;

new Core().readLines("./test.js");
