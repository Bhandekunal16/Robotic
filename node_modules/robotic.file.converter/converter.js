const readline = require("readline");
const fs = require("fs");

class Core {
  async arrow(path) {
    try {
      const lines = await this.readLines(path);
      const processedLines = this.processLines(lines);
      await this.writeLines(path, processedLines);
    } catch (e) {
      console.error(e);
    }
  }

  readLines(path) {
    return new Promise((resolve, reject) => {
      const readStream = fs.createReadStream(path, { encoding: "utf8" });
      const rl = readline.createInterface({
        input: readStream,
        crlfDelay: Infinity,
      });
      const lines = [];

      rl.on("line", (line) => {
        lines.push(line);
      });

      rl.on("close", () => [console.log("read successfully")]);
      rl.on("error", (error) => reject(error));
    });
  }

  processLines(lines) {
    return lines
      .map((line) => {
        if (/\b(function|const|var|module|export|import)\b/.test(line)) {
          if (!/\n\s*\n/.test(line) && !line.includes("/")) {
            line = line
              .replace(/\b(function|const|var|module|export|import)\b/, "\n$1")
              .trimStart();
          }
        }

        if (/\b(try|catch|for)\b/.test(line)) {
          if (!/\n\s*\n/.test(line)) {
            line = line
              .replace(/\b(try|catch|for)\b/, "\n$1")
              .trimStart()
              .replace(/\b(try|catch|for)\b/, "    $1");
          }
        }

        if (/\b(if|else|await|async)\b/.test(line)) {
          if (!/\n\s*\n/.test(line)) {
            line = line
              .replace(/\b(if|else|await|async)\b/, "\n$1")
              .trimStart()
              .replace(/\b(if|else|await|async)\b/, "        $1");
          }
        }

        line.includes("return")
          ? (line = line.trimStart().replace("return", "   return"))
          : line;

        line.includes("throw")
          ? (line = line.trimStart().replace("throw", "    throw"))
          : line;

        if (!line.includes("`")) {
          if (line.includes("})") || line.includes("}]")) {
            line = line;
          } else {
            if (
              !/\n\s*\n/.test(line) &&
              !line.includes("return") &&
              !line.includes("import") &&
              !line.includes("export") &&
              !line.includes("/")
            ) {
              line = line.replace(/\s*{\s*/g, "   {\n").replace(/\s*}/g, "}\n");
              !/\n\s*\n/g.test(line) ? line.replace(/\s*}/g, "") : line;
            }
          }
        }

        line = line.includes("/class")
          ? line
          : line.replace("class", "\nclass");

        line =
          line.includes(";") && !line.includes("for")
            ? line.replace(";", ";\n")
            : line;

        line.includes("let") && !line.includes("for") && !/\n\s*\n/.test(line)
          ? (line = line.replace("let", "\nlet").trimStart())
          : (line = line);

        return line;
      })
      .join("");
  }

  writeLines(path, content) {
    return new Promise((resolve, reject) => {
      fs.writeFile(path, content, "utf8", (error) => {
        if (error) return reject(error);
        resolve();
      });
    });
  }
}

module.exports = Core;

new Core().arrow("./test.js");
